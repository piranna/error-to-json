import {AssertionError} from 'assert'

import stringify from 'fast-safe-stringify'

export default errToJSON


const nonEnumerablePropsToCopy = ['code', 'errno', 'syscall']


let AssertionError_toJSON: Function | undefined
let Error_toJSON: Function | undefined


function Error_prototype_toJSON(this: Error) {
  const json = {
    // Add all enumerable properties
    ...this,
    // normal props
    name: this.name,
    message: this.message,
    stack: this.stack,
  }

  nonEnumerablePropsToCopy.forEach((key) => {
    // @ts-ignore
    if (key in this) json[key] = this[key]
  })

  return JSON.parse(stringify(json))
}

export function disable()
{
  // @ts-ignore
  if (AssertionError.prototype.toJSON === Error_prototype_toJSON) {
    // @ts-ignore
    AssertionError.prototype.toJSON = AssertionError_toJSON
    AssertionError_toJSON = undefined
  }

  // @ts-ignore
  if (Error.prototype.toJSON === Error_prototype_toJSON) {
    // @ts-ignore
    Error.prototype.toJSON = Error_toJSON
    Error_toJSON = undefined
  }
}

export function enable()
{
  // @ts-ignore
  if (Error.prototype.toJSON === Error_prototype_toJSON) return

  // AssertionError
  // @ts-ignore
  ;({toJSON: AssertionError_toJSON} = AssertionError.prototype)
  // @ts-ignore
  AssertionError.prototype.toJSON = Error_prototype_toJSON

  // Error
  // @ts-ignore
  ;({toJSON: Error_toJSON} = Error.prototype)
  // @ts-ignore
  Error.prototype.toJSON = Error_prototype_toJSON
}

export function errToJSON<T extends {}>(json: any): T {
  enable()

  // Get JSON representation of objects
  if(json.toJSON) json = json.toJSON()
  else if(isErrorAlike(json)) json = Error_prototype_toJSON.call(json)

  disable()

  // return error json
  return json
}

// HACK: found on the wild an `AssertionError` that extends from non default
//       `Error` class.
function isErrorAlike(error: any): boolean {
  return error != null
      // TODO: Both can be `undefined`, how can we properly detect them? See
      // https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-error.prototype.tostring
      && typeof error.message === 'string'
      && typeof error.name === 'string'
      // 'stack' is not standard, but widely supported, see
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack
      && 'stack' in error
}

export function parse(json: { message: string }) {
  const err = new Error(json.message)
  const stack = err.stack || ''
  Object.assign(err, json)
  if (err.stack === stack) {
    // remove stacktrace generated by error constructor above
    const index = stack.indexOf('\n')
    err.stack = stack.slice(0, index) + stack.slice(stack.indexOf('\n', index + 1))
  }
  return err
}
